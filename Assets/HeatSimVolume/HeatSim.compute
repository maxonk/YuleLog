#pragma kernel simulate
#pragma kernel testData

RWTexture3D<float4> HeatSimVolume;
Texture3D<float4> HeatSimVolumeLast; //512
SamplerState samplerHeatSimVolumeLast;
RWStructuredBuffer<float4> newPoints; //length 512 = x index
float _Time, _dTime;

[numthreads(32,1,32)]
void simulate(uint3 id : SV_DispatchThreadID) {
    //get the points from newPoints we might care about
    float newHeat = 0.0;
    float distToP, pInfluence;
    int floorY;
    if(newPoints[id.x].a != 0) {
        distToP = distance(newPoints[id.x].xyz, id.xyz);
        pInfluence = saturate(1 - distToP);
        newHeat += pInfluence;
    }
     
    //compute HeatSimVolume from HeatSimVolumeLast neighbors
    if(id.y > 0 && id.y < 128){
        /*
        float heat = HeatSimVolumeLast[cellIndex] * 0.1f;
        heat += HeatSimVolumeLast[cellIndex + int3(-1, 0, 0)] * 0.2; //adjacent
        heat += HeatSimVolumeLast[cellIndex + int3(1, 0, 0)] * 0.2; 
        heat += HeatSimVolumeLast[cellIndex + int3(0, 0, -1)] * 0.2; 
        heat += HeatSimVolumeLast[cellIndex + int3(0, 0, 1)] * 0.2;
        heat += HeatSimVolumeLast[cellIndex + int3(0, -1, 0)] * 0.1; //below
        */
        //trace backwards through velocity over dTime to find our previous position
        float heat = 0;
        float3 p01sampleSpace = id.xyz;
        p01sampleSpace.x /= 512.0;
        p01sampleSpace.y /= 128.0;
        p01sampleSpace.z /= 512.0;
        float3 v = HeatSimVolumeLast.SampleLevel(samplerHeatSimVolumeLast, p01sampleSpace, 0).xyz;
        v = float3(0,0,0);
        float3 p = p01sampleSpace - v * _dTime;        
        //new heat from outside simulation 
        float4 newData = HeatSimVolumeLast.SampleLevel(samplerHeatSimVolumeLast, p, 0);
        newData.y += newData.a;
        newData.a += newHeat;  
        HeatSimVolume[id.xyz] = newData; 
    }    
}

[numthreads(32,1,32)]
void testData(uint3 id : SV_DispatchThreadID) {
    for (int y = 0; y < 25; y++) { //do this with 32 dispatches instead probably..
        int3 cellIndex = int3(id.x, y, id.z);
        float data = //id.z / 512.0;
            min(
                max(pow(1 - (abs(256 - cellIndex.z) / 256.0), 4), 0),
                max(pow(1 - (abs(256 - cellIndex.x) / 256.0), 4), 0)
            )
            * max((50 - cellIndex.y) / 25.0, 0); //test obv

        if(min(min(cellIndex.x, cellIndex.y), cellIndex.z) <= 0) data = 0;
        if(max(max(cellIndex.x, cellIndex.y), cellIndex.z) >= 511) data = 0;
        HeatSimVolume[cellIndex] = float4(0,0,0,data);
       // HeatSimVolumeLast[cellIndex] = data;   this is now read only which might break this testdata function..
    }
}

