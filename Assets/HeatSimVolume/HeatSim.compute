#pragma kernel simulate
#pragma kernel insert
#pragma kernel clearLogVol
#pragma kernel testData

RWTexture3D<float4> HeatSimVolumeNext, FuelSmokeSimVolNext;
Texture3D<float4> HeatSimVolumeLast, FuelSmokeSimVolLast; //255
RWTexture3D<float4> LogInsertionVolumeRW;
Texture2D<float4> NoiseTex;
SamplerState samplerHeatSimVolumeLast, samplerFuelSmokeSimVolLast, samplerNoiseTex;
RWStructuredBuffer<float4> newPoints, newVelocity; //length 256 
float _Time, _dTime;

float4 Sample(Texture3D<float4> tex, SamplerState ss, float3 p) {
	return tex.SampleLevel(ss, saturate(p * float3(1.0 / 128.0, 1.0 / 128.0, 1.0 / 128.0)), 0);
}

float pInfluence(float distToP){
	return smoothstep(0, 1, pow(saturate((2.8 - distToP) / 2.8), 2));
}

[numthreads(1,1,1)]
void simulate(uint3 id : SV_DispatchThreadID) {
     
    //compute HeatSimVolume from HeatSimVolumeLast neighbors
    if(id.y > 0 && id.y < 127){
		// move to sample space from world right away and do ops here. this is bad and we should undo maybe if we can afford the ops? - it squashes velocity in the vertical i think...
        float3 p = (float3)id.xyz + float3(0.5, 0.5, 0.5);
        
		//get our current data from the texture
        //DIFFUSE the neighbor cells into it slightly to try for spreading?
        float4 velocityHeat = Sample(HeatSimVolumeLast, samplerHeatSimVolumeLast, p); //+ newVH;
		/*	+ Sample(HeatSimVolumeLast, samplerHeatSimVolumeLast, p + float3(0, _dTime, 0))
			 + Sample(HeatSimVolumeLast, samplerHeatSimVolumeLast, p + float3(0, -_dTime, 0))
			 + Sample(HeatSimVolumeLast, samplerHeatSimVolumeLast, p + float3(_dTime, 0, 0))
			 + Sample(HeatSimVolumeLast, samplerHeatSimVolumeLast, p + float3(-_dTime, 0, 0))
			 + Sample(HeatSimVolumeLast, samplerHeatSimVolumeLast, p + float3(0, 0, _dTime))
			 + Sample(HeatSimVolumeLast, samplerHeatSimVolumeLast, p + float3(0, 0, -_dTime));
		velocityHeat /= 7.0; //  all of these samples were too expensive */

		float4 fuelSmoke = Sample(FuelSmokeSimVolLast, samplerFuelSmokeSimVolLast, p);
      /*   + Sample(FuelSmokeSimVolLast, samplerFuelSmokeSimVolLast, p + float3(0, _dTime * 4.0, 0))
         + Sample(FuelSmokeSimVolLast, samplerFuelSmokeSimVolLast, p + float3(0, -_dTime * 4.0, 0))
         + Sample(FuelSmokeSimVolLast, samplerFuelSmokeSimVolLast, p + float3(_dTime * 4.0, 0, 0))
         + Sample(FuelSmokeSimVolLast, samplerFuelSmokeSimVolLast, p + float3(-_dTime * 4.0, 0, 0))
         + Sample(FuelSmokeSimVolLast, samplerFuelSmokeSimVolLast, p + float3(0, 0, _dTime * 4.0))
         + Sample(FuelSmokeSimVolLast, samplerFuelSmokeSimVolLast, p + float3(0, 0, -_dTime * 4.0));
		 fuelSmoke /= 7.0; */
		 
		 float4 noiseSample = NoiseTex.SampleLevel(samplerNoiseTex, (p.xz / 128.0) + float2(_Time * 1.5, _Time * 2.3), 0);

		//OUTSIDE ADDITION
		float4 newVH = LogInsertionVolumeRW[id.xyz];
		LogInsertionVolumeRW[id.xyz] = float4(0,0,0,0);
		velocityHeat.xyz += newVH.xyz;
		velocityHeat.y += newVH.a * 0.1;
		velocityHeat.a += newVH.a * 0.8;
		fuelSmoke.y += newVH.a * 0.01;

		 //BACKGROUND HEAT / MAX HEAT
		 velocityHeat.a = clamp(velocityHeat.a, 0.40, 1.075);

		//ADVECTION
        //evolve forward to get the naive estimation
		float3 samplePos = p - velocityHeat.xyz * _dTime * 1.0;
        float4 fwdEvolvedVelocityHeat = Sample(HeatSimVolumeLast, samplerHeatSimVolumeLast, samplePos);
		float4 fwdEvolvedFuelSmoke = Sample(FuelSmokeSimVolLast, samplerFuelSmokeSimVolLast, samplePos);

		//move forward and then back and then see what the difference is - that's our error sampling position
		samplePos = (samplePos // fast forward 
							+ fwdEvolvedVelocityHeat.xyz * _dTime * 1.0); // rewind
		
		//the error is accumulated over 2 timesteps so cut it in half and that's our correction
		float4 correctedForwardVH = 
			fwdEvolvedVelocityHeat - (
				(Sample(HeatSimVolumeLast, samplerHeatSimVolumeLast, samplePos) //fwd evolved then back projected VH
				- velocityHeat) / 2.0 //diff / 2 = correction
			); 
	//	correctedForwardVH.xyz = fwdEvolvedVelocityHeat.xyz;//nvidia says not to do fwdback correction for velocity for some reason?

		float4 correctedForwardFS = 
			fwdEvolvedFuelSmoke - (
				(Sample(FuelSmokeSimVolLast, samplerFuelSmokeSimVolLast, samplePos)
				- fuelSmoke) / 2.0
			);
		//HEAT = UPWARD ACCELERATION  
		correctedForwardVH.y += (correctedForwardVH.a) * 20.0 * _dTime;
		
		//COOLING and DISSIPATION 
		correctedForwardVH.a -= pow(max(0, correctedForwardVH.a - 0.4) * 2, 3) * 1.0 * _dTime;
        //correctedForwardFS.y = max(0.0, correctedForwardFS.y - pow(correctedForwardFS.y, 1) * 0.2 * _dTime); //smoke density
		
		
	  //   this does nothing (since we're not projecting i think?) - lets replace it with background noise
	//	velocityHeat.xyz += 10.0 * newH * (noiseSample);

		//friction or something for velocity here too
	//	correctedForwardVH.xyz += 
	/*	correctedForwardVH.xyz = lerp( 
			correctedForwardVH.xyz, //lerp from our velocity to environmental velocity by a damping factor
			noiseSample.xyz * (10.0.xxx) - (2.50.xxx),
			(_dTime * 5.00).xxx 
		);*/
		
		//clamping to stop weirdness??
		correctedForwardVH.a = clamp(correctedForwardVH.a, 0.4, 1.075);

		//aaaand write out to texture
        //BUT AT SOME POINT WE SHOULD PROJECT A BIT FORWARD TOO BY VELOCITY OTHERWISE WE GETTIN NOWHERES - how do tho
        HeatSimVolumeNext[id.xyz] = correctedForwardVH;
		correctedForwardFS.x = correctedForwardVH.a; //copying to the other tex so we can sample just one in frag
		correctedForwardFS.y = clamp(correctedForwardFS.y, 0, 1);
        FuelSmokeSimVolNext[id.xyz] = correctedForwardFS;

    }    
} 

#define INSERTION_SCALE 8

void insert(int3 index, float3 pos, float3 velocity, float heat){
	LogInsertionVolumeRW[index] += 
		float4(velocity, heat) * pInfluence(distance(float3(index), pos));
}

void insertXRow(int3 index, float3 pos, float3 velocity, float heat){
	index.x -= INSERTION_SCALE;
	insert(index, pos, velocity, heat);
	for(int i = 0; i < INSERTION_SCALE * 2; i++) {
		index.x++;
		insert(index, pos, velocity, heat);
	}
	index.x -= INSERTION_SCALE;
}

void insertXYQuad(int3 index, float3 pos, float3 velocity, float heat){
	index.y -= INSERTION_SCALE;
	insertXRow(index, pos, velocity, heat);
	for(int i = 0; i < INSERTION_SCALE * 2; i++){
		index.y++;
		insertXRow(index, pos, velocity, heat);
	}
	index.y -= INSERTION_SCALE; 
}

[numthreads(1,1,1)]
void insert(uint3 id : SV_DispatchThreadID) {
	//instead of just points, can we do actual geo? or like the full node map with connections and fill between them?
	int3 index = round(newPoints[id.x].xyz);

	index.z -= INSERTION_SCALE;
	insertXYQuad(index, newPoints[id.x].xyz, newVelocity[id.x].xyz, newPoints[id.x].a); 
	for(int i = 0; i < INSERTION_SCALE * 2; i++){
		index.z++;
		insertXYQuad(index, newPoints[id.x].xyz, newVelocity[id.x].xyz, newPoints[id.x].a);
	}
} 

[numthreads(1,1,1)]
void clearLogVol(uint3 id : SV_DispatchThreadID) {
	LogInsertionVolumeRW[id.xyz] = 0.0;
}
 
[numthreads(1,1,1)]
void testData(uint3 id : SV_DispatchThreadID) {
    insert(id.xyz + uint3(0, 10, 0), id.xyz + float3(0, 10, 0), id.xyz + float3(0,10,0), 0.01);
}

