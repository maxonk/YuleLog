#pragma kernel simulate
#pragma kernel insert
#pragma kernel clearLogVol
#pragma kernel testData

RWTexture3D<float4> HeatSimVolumeNext, FuelSmokeSimVolNext;
Texture3D<float4> HeatSimVolumeLast, FuelSmokeSimVolLast; //255
RWTexture3D<float4> LogInsertionVolumeRW;
Texture2D<float4> NoiseTex;
SamplerState samplerHeatSimVolumeLast, samplerFuelSmokeSimVolLast, samplerNoiseTex;
RWStructuredBuffer<float4> newPoints, newVelocity; //length 256 
float _Time, _dTime;

float4 Sample(Texture3D<float4> tex, SamplerState ss, float3 p) {
	return tex.SampleLevel(ss, saturate(p * float3(1.0 / 128.0, 1.0 / 128.0, 1.0 / 128.0)), 0);
}

#define MIN_HEAT 0.4
#define MAX_HEAT 1.075
#define AMBIENT_MASS 0.000001

[numthreads(1,1,1)]
void simulate(uint3 id : SV_DispatchThreadID) {
     
    //compute HeatSimVolume from HeatSimVolumeLast neighbors
    if(id.y > 0 && id.y < 127){
		// move to sample space from world right away and do ops here. this is bad and we should undo maybe if we can afford the ops? - it squashes velocity in the vertical i think...
        float3 p = (float3)id.xyz + float3(0.5, 0.5, 0.5);
        
		//get our current data from the texture
        float4 velocityHeat = Sample(HeatSimVolumeLast, samplerHeatSimVolumeLast, p); 
		float4 fuelSmoke = Sample(FuelSmokeSimVolLast, samplerFuelSmokeSimVolLast, p);
		 
		float4 noiseSample = NoiseTex.SampleLevel(samplerNoiseTex, (p.xz / 128.0) + float2(_Time * 1.5, _Time * 2.3), 0);

		//OUTSIDE ADDITION
		float4 newVH = LogInsertionVolumeRW[id.xyz];
		LogInsertionVolumeRW[id.xyz] = float4(0,0,0,0);
		velocityHeat.xyz += newVH.xyz;
		velocityHeat.y += newVH.a * 0.1;
		velocityHeat.a += newVH.a * 1.0;
//		fuelSmoke.y += newVH.a * 0.001;

		//GENERATE SMOKE FROM BURNING IMAGINARY FUEL
		//fuelSmoke.y += (velocityHeat.a - MIN_HEAT) * 0.001 * _dTime;

		 //BACKGROUND HEAT / MAX HEAT
		 velocityHeat.a = clamp(velocityHeat.a, 0.40, 1.075);

		//ADVECTION
        //evolve forward to get the naive estimation
		float3 samplePos = p - velocityHeat.xyz * _dTime * 1.0;
        float4 fwdEvolvedVelocityHeat = Sample(HeatSimVolumeLast, samplerHeatSimVolumeLast, samplePos);
		float4 fwdEvolvedFuelSmoke = Sample(FuelSmokeSimVolLast, samplerFuelSmokeSimVolLast, samplePos);

		//move forward and then back and then see what the difference is - that's our error sampling position
		samplePos = (samplePos // fast forward 
							+ fwdEvolvedVelocityHeat.xyz * _dTime * 1.0); // rewind
		
		//the error is accumulated over 2 timesteps so cut it in half and that's our correction
		float4 correctedForwardVH = 
			fwdEvolvedVelocityHeat - (
				(Sample(HeatSimVolumeLast, samplerHeatSimVolumeLast, samplePos) //fwd evolved then back projected VH
				- velocityHeat) / 2.0 //diff / 2 = correction
			); 
	//	correctedForwardVH.xyz = fwdEvolvedVelocityHeat.xyz;//nvidia says not to do fwdback correction for velocity for some reason?

		float4 correctedForwardFS = 
			fwdEvolvedFuelSmoke - (
				(Sample(FuelSmokeSimVolLast, samplerFuelSmokeSimVolLast, samplePos)
				- fuelSmoke) / 2.0
			);

		//HEAT = UPWARD ACCELERATION  
		correctedForwardVH.y += 
			(correctedForwardVH.a * 120.0) /// (correctedForwardFS.y)  // force here is heat * constant
			* _dTime;

		//GRAVITY PULLS SMOKE
		correctedForwardVH.y -=			//		dx =                       F = ma ... a = F/m ... a = dx / dt
			(0.000005 / max(correctedForwardFS.y, AMBIENT_MASS))	//		(Force	/	Mass)
			*	_dTime;						//			*	deltaTime
					
		//COOLING
		correctedForwardVH.a -= _dTime * //time scaled
			pow(
				saturate(correctedForwardVH.a - MIN_HEAT / (MAX_HEAT - MIN_HEAT)), 
				4) //pow curve height - this is a constant suggested by nvidia
			* 150.0; //constant factor
		
		//DISSIPATION OF SMOKE
	/*	correctedForwardFS.y -= _dTime * //time scaled
			pow(
				correctedForwardFS.y,  //more influence when theres more smoke - friction-like
				1.25) //pow curve height - higher means the dissipation output is more forgiving in the middle range
			* 10.0; //constant factor  */

		//ASSIGNING OUR OUTPUT
		//clamping ranges here too
		correctedForwardVH.a = clamp(correctedForwardVH.a, MIN_HEAT, MAX_HEAT);
		correctedForwardFS.x = correctedForwardVH.a; //copying to the other tex so we can sample just one in frag
		correctedForwardFS.y = clamp(correctedForwardFS.y, 0, 1);
	/*	correctedForwardVH.xyz = lerp( 
			correctedForwardVH.xyz, //lerp from our velocity to environmental velocity by a damping factor
			noiseSample.xyz * (10.0.xxx) - (2.50.xxx),
			(_dTime * 5.00).xxx 
		);*/
		

		//aaaand write out to texture
        //BUT AT SOME POINT WE SHOULD PROJECT A BIT FORWARD TOO BY VELOCITY OTHERWISE WE GETTIN NOWHERES - how do tho
        HeatSimVolumeNext[id.xyz] = correctedForwardVH;
        FuelSmokeSimVolNext[id.xyz] = correctedForwardFS;

    }    
} 

//REGION -- INSERTION ------------------------------------------------------------------------------------------------

#define INSERTION_SCALE 6

#define P_INFLUENCE_DIST_MAX 2.50
#define P_INFLUENCE_DIST_MIN 1.50
float pInfluence(float distToP){
	return 
		(1 - //invert
			saturate( //remap my distance from 1.0-->2.8 space to 0.0-->1.0 space
				(distToP - P_INFLUENCE_DIST_MIN) / (P_INFLUENCE_DIST_MAX - P_INFLUENCE_DIST_MIN)
			)
		);
}

void insert(int3 index, float3 pos, float3 velocity, float heat){
	LogInsertionVolumeRW[index] += 
		float4(velocity, heat) * pInfluence(distance(float3(index), pos));
}

void insertXRow(int3 index, float3 pos, float3 velocity, float heat){
	index.x -= INSERTION_SCALE;
	insert(index, pos, velocity, heat);
	for(int i = 0; i < INSERTION_SCALE * 2; i++) {
		index.x++;
		insert(index, pos, velocity, heat);
	}
	index.x -= INSERTION_SCALE;
}

void insertXYQuad(int3 index, float3 pos, float3 velocity, float heat){
	index.y -= INSERTION_SCALE;
	insertXRow(index, pos, velocity, heat);
	for(int i = 0; i < INSERTION_SCALE * 2; i++){
		index.y++;
		insertXRow(index, pos, velocity, heat);
	}
	index.y -= INSERTION_SCALE; 
}

[numthreads(1,1,1)]
void insert(uint3 id : SV_DispatchThreadID) {
	//instead of just points, can we do actual geo? or like the full node map with connections and fill between them?
	int3 index = round(newPoints[id.x].xyz);

	index.z -= INSERTION_SCALE;
	insertXYQuad(index, newPoints[id.x].xyz, newVelocity[id.x].xyz, newPoints[id.x].a); 
	for(int i = 0; i < INSERTION_SCALE * 2; i++){
		index.z++;
		insertXYQuad(index, newPoints[id.x].xyz, newVelocity[id.x].xyz, newPoints[id.x].a);
	}
} 

[numthreads(1,1,1)]
void clearLogVol(uint3 id : SV_DispatchThreadID) {
	LogInsertionVolumeRW[id.xyz] = 0.0;
}
 
[numthreads(1,1,1)]
void testData(uint3 id : SV_DispatchThreadID) {
    insert(id.xyz + uint3(0, 10, 0), id.xyz + float3(0, 10, 0), id.xyz + float3(0,10,0), 0.01);
}

